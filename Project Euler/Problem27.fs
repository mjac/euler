module Euler.Problems.Problem27

open Euler.Prime

let maxProduct limit = 
    let s = primeList (limit - 1)
    let rec listSeq a b n = let p = n*n+n*a+b in if isPrime p then listSeq a b (n+1) else n
    let pairs = Seq.collect (fun a -> Seq.map (fun b -> (a,b)) s) [-limit/2..limit/2]
    let a,b,c = Seq.fold (fun (u,v,w) (a,b) -> let w2 = listSeq a b 0 in if w2 > w then (a,b,w2) else (u,v,w)) (0,0,0) pairs
    a,b,c

(*
I did not use a computer to solve this problem.
The formula n^2-79n+1601 is nothing more than (n-40)^2+n-40+41
so that all the forty primes of n^2+n+41 are met twice that's why 80 primes are found,
but only 40 different one's.
So what I did was:
take (n-p)^2+n-p+41, working out this formula gives:
n^2-(2p-1)n+p^2-p+41.
Now |2p-1|<1000 and |p^2-p+41|<1000.
The second condition gives -30<=p<=31
The value p=31 gives the most primes.
So the numbers are -(2*31-1)=-61 and 31^2-31+41=971.
See also: http://mathworld.wolfram.com/Prime-GeneratingPolynomial.html

25 Jul 2005 10:28 pm 
Eve   (APL/J/K)  Eve is from England
Like you, hk, I didn't write a program to solve this one. I was helped by looking at the primes 
generated by the two examples and finding they contained the same numbers! The second differences 
in every quadratic case, irrespective of the values of a or b, must be 2:

41 43 47 53 61 71 ...
1st difference 2 4 6 8 10 ...
2nd difference 2 2 2 2 ...

This suggested to me that the sequence beginning at 41 was very special, something I verified by 
applying these differences to larger primes and generating only very short strings of primes.
So I deduced that the answer must use the same sequence, reducing from the prime in the sequence 
which is the greatest below 1000, i.e. 971, as this becomes b (which must be less than 1000). 
*)